#!/bin/bash

set -e # Exit on error

PrintInfo() {
    local message=$1
    echo -e "[${green}INFO${nc}] $message"
}

PrintError() {
    local message=$1
    echo -e "[${red}ERROR${nc}] $message"
}

Panic() {
    local message=$1
    local beforeExit=$2
    PrintError "$message"
    [[ -n "$beforeExit" ]] && $beforeExit
    exit 1
}

ExpandVariables() {
    local replaced_string=$(eval "echo \"$1\"")  # Evaluate and expand variables
    echo "$replaced_string"
}

GetProfileValue() {
    local key="$1"
    local value=$(echo "$profile" | jq -r ".${key}")
    if [[ "$value" != "null" ]]; then
        echo "$value"
        return
    fi

    echo ""
}

ExecuteProfileCommand() {
    # profile commands are an array of strings, so we need to join them first with jq
    # also profile commands might have $ variables so we need to expand them
    local key="$1"
    local profile_commands=$(GetProfileValue "$key") # Assuming GetProfileValue retrieves the profile commands

    if [ -n "$profile_commands" ]; then
        local commands=$(echo "$profile_commands" | jq -r 'join("\n")')
        if [[ $? -ne 0 ]]; then
            PrintError "Failed to parse $key commands."
            return 1
        fi
        local expanded_commands=$(ExpandVariables "$commands")
        PrintInfo "Executing profile command $key..."
        docker exec -u "$config_RemoteUser" -it "$containerId" bash -c "$expanded_commands"
        if [[ $? -ne 0 ]]; then
            PrintError "Executing $key failed."
            return 1
        fi
    fi
    return 0
}


ProfileVolumesAsDockerArgs() {
    # volumes might have $ variables so we need to expand them first
    local volumes=$(GetProfileValue "volumes")
    if [[ -n "$volumes" ]]; then
        local volume=""
        while IFS= read -r line; do
            volume="$volume -v \"$line\""
        done <<< "$(jq -r ".volumes | .[]" <<< "$profile")"
        if [[ $? -ne 0 ]]; then
            PrintError "Failed to parse volumes."
            return 1
        fi
        volume=$(ExpandVariables "$volume")
        echo "$volume"
    fi
}


FindProjectConfig() {
    local paths=(
        "$projectPath/devcontainer.json"
        "$projectPath/.devcontainer/devcontainer.json"
    )

    for path in "${paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return
        fi
    done
}

GetConfigValue() {
    local key="$1"

    local value=$(echo "$projectConfig" | jq -r ".${key}")
    if [[ "$value" != "null" ]]; then
        echo "$value"
        return
    fi

    local metadataValue=$(echo "$imageConfig" | jq -r ". | reverse | .[] | select(.${key} != null) | .${key}" | head -n 1)
    if [[ "$metadataValue" != "" && "$metadataValue" != "null" ]]; then
        echo "$metadataValue"
        return
    fi

    echo ""
}

ExecuteConfigCommand() {
    local key="$1"
    local command=$(GetConfigValue "$key")

    if [[ -n "$command" ]]; then
        PrintInfo "Executing config command $key..."
        docker exec -u "$config_RemoteUser" -it "$containerId" bash -c "$command"
        if [[ $? -ne 0 ]]; then
            PrintError "Executing $key failed."
            return 1
        fi
    fi

    return 0
}

green='\033[0;32m'
red='\033[0;31m'
nc='\033[0m'

homeDirectory="$HOME"
configDir="$homeDirectory/.config/nvim-devcontainer-dd"
profilesDir="$configDir/profiles"

arg_ProjectPath=""
for ((i = 2; i <= $#; i++)); do
    arg_ProjectPath="$arg_ProjectPath ${!i}"
done
if [[ -n "$arg_ProjectPath" ]]; then
    projectPath=$(realpath "$arg_ProjectPath")
else
    projectPath=$(realpath "$(pwd)")
fi
projectName=$(basename "$projectPath")

projectConfigPath=$(FindProjectConfig) && [[ ! -f "$projectConfigPath" ]] && Panic "No devcontainer.json found."
projectConfigDir=$(dirname "$projectConfigPath")
projectConfig=$(sed '/^\s*\/\/.*\|\/\*.*\*\/\s*$/d' "$projectConfigPath") && [[ -z "$projectConfig" ]] && Panic "Failed to read devcontainer.json."

containerId=$(docker ps -aq -f "label=nvim-devcontainer-$projectPath")
containerLabel="nvim-devcontainer-$projectPath"
config_Dockerfile=$(GetConfigValue 'build.dockerfile')

if [[ -n "$config_Dockerfile" ]]; then
    dockerfilePath="$projectConfigDir/$config_Dockerfile"
    config_Image="nvim-devcontainer--$projectName--$(sha256sum "$dockerfilePath" | awk '{print $1}')"
else
    config_Image=$(GetConfigValue 'image') && [[ -z "$config_Image" ]] && Panic "No image specified in devcontainer.json."
fi

PrintInfo "Using Docker image \"$config_Image\"..."
imageConfig=$(docker inspect --format='{{index .Config.Labels "devcontainer.metadata"}}' "$config_Image")
config_RemoteUser=$(GetConfigValue 'remoteUser')
if [[ -z "$config_RemoteUser" ]]; then
    config_RemoteUser="root"
    containerHomeDir="/root"
else
    containerHomeDir="/home/$config_RemoteUser"
fi



defaultProfileName="nvim"
defaultProfile='{
    "volumes": [
        "$configDir/nvim/config:$containerHomeDir/.config/nvim",
        "$configDir/nvim/cache:$containerHomeDir/.cache/nvim",
        "$configDir/nvim/local/state:$containerHomeDir/.local/state",
        "$configDir/nvim/local/share/nvim:$containerHomeDir/.local/share/nvim",
        "$configDir/nvim/local/share/nvim-linux64:$containerHomeDir/.local/share/nvim-linux64"
    ],
    "env": {},
    "installCommand": [
        "if [ ! -f $containerHomeDir/.local/share/nvim-linux64/bin/nvim ]; then",
        "    cd /tmp &&",
        "    curl -LO \"https://github.com/neovim/neovim/releases/latest/download/nvim-linux64.tar.gz\" &&",
        "    tar xzf nvim-linux64.tar.gz &&",
        "    mkdir -p $containerHomeDir/.local/share &&",
        "    mv ./nvim-linux64/* $containerHomeDir/.local/share/nvim-linux64/",
        "fi",
        "",
        "chmod +x \"$containerHomeDir/.local/share/nvim-linux64/bin/nvim\"",
        "",
        "mkdir -p $containerHomeDir/.local/bin",
        "cd $containerHomeDir/.local/bin/ &&",
        "ln -sf $containerHomeDir/.local/share/nvim-linux64/bin/nvim nvim"
    ],
    "attachCommand": ["$containerHomeDir/.local/bin/nvim"]
}';


mkdir -p "$profilesDir"
if [[ ! -f "$profilesDir/$defaultProfileName.json" ]]; then
    echo "$defaultProfile" >"$profilesDir/$defaultProfileName.json"
fi
arg_ProfileName=$1 && [[ -z "$arg_ProfileName" ]] && Panic "No profile name specified."
profilePath="$profilesDir/$arg_ProfileName.json" && [[ ! -f "$profilePath" ]] && Panic "Profile \"$arg_ProfileName\" not found."
profile=$(cat "$profilePath") && [[ -z "$profile" ]] && Panic "Failed to read profile \"$arg_ProfileName\"."


if [ -z "$containerId" ]; then
    if [[ -n "$config_Dockerfile" ]]; then
        PrintInfo "Building Docker image using $dockerfilePath..."
        docker build -t "$config_Image" -f "$dockerfilePath" "$projectConfigDir" || Panic "Building Docker image failed."
    else
        PrintInfo "Pulling Docker image \"$config_Image\"..."
        docker pull "$config_Image" || Panic "Pulling Docker image failed."
    fi

    PrintInfo "Creating container for \"$projectPath\" project..."

    docker run --net=host -w "/workspaces/$projectName" \
        -v "$projectPath:/workspaces/$projectName" \
        $(ProfileVolumesAsDockerArgs) \
        -v "$homeDirectory/.gitconfig:/etc/gitconfig" \
        -v /tmp/.X11-unix:/tmp/.X11-unix \
        -u root \
        -e DISPLAY=$DISPLAY \
        -e SHELL=/bin/bash \
        -d --label "$containerLabel" "$config_Image" bash -c "
            sleep 10
            while [ \$(ls /dev/pts | wc -l) -gt 1 ]; do
                sleep 10
            done
        " || Panic "Creating container failed."

    containerId=$(docker ps -aq -f "label=$containerLabel")
    PrintInfo "Container created with ID \"$containerId\"."

    PrintInfo "Initializing container..."

    InitializationPanic() {
        Panic "Initialization failed." "docker rm -f $containerId"
    }

    docker exec -u "$config_RemoteUser" \
        -it "$containerId" \
        bash -c "            
            sudo chown -R $config_RemoteUser /workspaces
            sudo chown -R $config_RemoteUser $containerHomeDir
        " || InitializationPanic

    ExecuteProfileCommand "installCommand" || InitializationPanic
    ExecuteConfigCommand "postCreateCommand" || InitializationPanic
fi

# Attach to the container

PrintInfo "Attaching to the container \"$containerId\" project..."

AttachWithBash() {
    PrintInfo "Attaching the container with bash..."
    docker exec -u "$config_RemoteUser" -it "$containerId" bash
}

AttachingFailed() {
    Panic "Attaching to the container failed." "AttachWithBash"
}

if [ "$(docker inspect -f '{{.State.Running}}' "$containerId")" == "false" ]; then
    PrintInfo "Container is not running. Starting it..."
    docker start "$containerId" || AttachingFailed
    ExecuteConfigCommand "postStartCommand" || AttachingFailed
fi

ExecuteConfigCommand "postAttachCommand" || AttachingFailed
ExecuteProfileCommand "attachCommand" || AttachingFailed
